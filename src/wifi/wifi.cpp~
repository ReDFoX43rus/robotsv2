#include <stdio.h>
#include <string.h>
#include <sys/fcntl.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "nvs_flash.h"
#include "esp_event_loop.h"
#include "esp_log.h"
#include "lwip/err.h"

#include "iobase/uart/uart.h"
#include "lwip/sys.h"
#include "lwip/netdb.h"
#include "lwip/dns.h"
#include "wifi/wifi.h"

#include "fileio.h"
#include "uart.h"


CWifi::CWifi(/*CWifiIO *wio*/){
	//ESP_ERROR_CHECK( esp_event_loop_init(event_handler, NULL) );    //ZVEZDA
	wifi_event_group = xEventGroupCreate();

	//m_Wio = wio;
}

CWifi::~CWifi(){
	wifi_started = false;
}

// void CWifi::wifi_stop(){
//
// 	xEventGroupSetBits(wifi_event_group, WAIT_FOR_STOP_BIT);
// 	 vTaskDelay(5000 / portTICK_PERIOD_MS);
// 	 ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));
// 	 ESP_ERROR_CHECK(esp_wifi_stop());
// 	 ESP_ERROR_CHECK(esp_wifi_deinit());
// }

void CWifi::wifi_start(){
		start_dhcp_server();
		wifi_init_softap();
		wifi_started = true;
		xTaskCreate(this->tcp_server_init,"tcp_server_init",4096,this,5,NULL);
		xTaskCreate(&print_sta_info,"print_sta_info",4096,NULL,5, NULL);
}

void CWifi::acces_point_update(){
	ESP_ERROR_CHECK( esp_event_loop_init(event_handler, NULL) );
	start_dhcp_server();
	wifi_init_softap();
	vTaskDelay(4000 / portTICK_PERIOD_MS);
	tcp_server_init(NULL);
}

static esp_err_t event_handler(void *ctx, system_event_t *event)
{
	switch(event->event_id) {
		case SYSTEM_EVENT_AP_START:
		printf("Event:ESP32 is started in AP mode\n");
		xEventGroupSetBits(wifi_event_group, AP_STARTED_BIT);
		break;

	case SYSTEM_EVENT_AP_STACONNECTED:
		xEventGroupSetBits(wifi_event_group, CLIENT_CONNECTED_BIT);
		print_sta_info(NULL);
		break;

	case SYSTEM_EVENT_AP_STADISCONNECTED:
		xEventGroupSetBits(wifi_event_group, CLIENT_DISCONNECTED_BIT);
		break;
	default:
		break;
	}
	return ESP_OK;
}


void CWifi::wifi_init_softap(){
	esp_log_level_set("wifi", ESP_LOG_NONE);

	esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
        // OTA app partition table has a smaller NVS partition size than the non-OTA
        // partition table. This size mismatch may cause NVS initialization to fail.
        // If this happens, we erase NVS partition and initialize NVS again.
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
	ESP_ERROR_CHECK( err );

	const uint8_t ssid[32] =  "esp32";

	const uint8_t ssid_len = 5;

	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
	ESP_ERROR_CHECK(esp_wifi_init(&cfg));

	esp_wifi_set_storage(WIFI_STORAGE_RAM);
	esp_wifi_set_mode(WIFI_MODE_AP);


	const wifi_auth_mode_t mode = WIFI_AUTH_OPEN;
	const uint8_t max_connection = 1;
	const uint16_t beacon_interval = 100;
	//const uint8_t password[32] = "ddn53775ddn";

	wifi_config_t wifi_config;

	memcpy(wifi_config.ap.ssid, ssid, ssid_len);
	//memcpy(wifi_config.ap.password, password, 11);
	wifi_config.ap.ssid_len = ssid_len;
	wifi_config.ap.max_connection = max_connection;
	//wifi_config.ap.authmode = WIFI_AUTH_WPA_WPA2_PSK;
	wifi_config.ap.authmode = mode;
	wifi_config.ap.beacon_interval = beacon_interval;


	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
	ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config));
	ESP_ERROR_CHECK(esp_wifi_start());

	ESP_LOGI(TAG, "wifi_init_softap finished.SSID:%s password:%s \n",
			 ssid, "OPEN");
}

void CWifi::tcp_server_init(void* arg){
	CWifi *_this = (CWifi*)arg;
	int listeners_count = 2;

	ESP_LOGI(TAG,"tcp_server task started \n");
	struct sockaddr_in tcpServerAddr;
	tcpServerAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	tcpServerAddr.sin_family = AF_INET;
	tcpServerAddr.sin_port = htons( 3000 );
	int r;
	int socket;
	char recv_buf[64];
	static struct sockaddr_in remote_addr;
	static unsigned int socklen;

	socklen = sizeof(remote_addr);
	int client_socket; //client socket
	xEventGroupWaitBits(wifi_event_group,AP_STARTED_BIT,false,true,portMAX_DELAY);    //ZVEZDA

	while(1){
		socket = socket(AF_INET, SOCK_STREAM, 0);
		if(socket < 0) {
			ESP_LOGE(TAG, "... Failed to allocate socket.\n");
			vTaskDelay(1000 / portTICK_PERIOD_MS);
			continue;
		}
		ESP_LOGI(TAG, "... allocated socket\n");
		if(bind(socket, (struct sockaddr *)&tcpServerAddr, sizeof(tcpServerAddr)) != 0) {
			ESP_LOGE(TAG, "... socket bind failed errno=%d \n", errno);
			close(socket);
			vTaskDelay(4000 / portTICK_PERIOD_MS);
			continue;
		}
		ESP_LOGI(TAG, "... socket bind done \n");
		if(listen (socket, listeners_count) != 0) {
			ESP_LOGE(TAG, "... socket listen failed errno=%d \n", errno);
			close(socket);
			vTaskDelay(4000 / portTICK_PERIOD_MS);
			continue;
		}
		while(1){
			/* Make sure new client will get respone only for him */
			// if(_this->m_Wio->m_Error){
			// 	_this->m_Wio->m_Error = 0;
			// 	_this->m_Wio->FlushWriteBuffer();
			// }

			client_socket = accept(socket,(struct sockaddr *)&remote_addr, &socklen);

			ESP_LOGI(TAG,"New connection request, Request data:");

			CFile file = CFile("/fat/esp32_robots.bin", FM_WRITE);
			if(!file.IsOpened()){
				uart << "Cannot open file to save wifi export" << endl;
				close(client_socket);
				continue;
			}

			//fcntl(client_socket,F_SETFL,O_NONBLOCK);
			do {
				bzero(recv_buf, sizeof(recv_buf));
				r = recv(client_socket, recv_buf, sizeof(recv_buf)-1,0);

				// if(r > 0)
				// 	_this->m_Wio->WriteToReadBuff(recv_buf, r);

				if(r > 0){
					file.Write(recv_buf, r);
					//uart.Write(recv_buf, r);
				}
			} while(r > 0);


			ESP_LOGI(TAG, "... done reading from socket. Last read return=%d errno=%d\r\n", r, errno);
			xEventGroupSetBits(wifi_event_group, DOWNLOADED_BIT);

			/*if( write(client_socket , message , sizeof(message)) < 0)
			{
				ESP_LOGE(TAG, "... Send failed \n");
				close(socket);
				vTaskDelay(4000 / portTICK_PERIOD_MS);
				continue;
			}*/

			// if(_this->response_to_client(client_socket) < 0){
			// 	ESP_LOGE(TAG, "... Response failed \n");
			// 	close(socket);
			// 	vTaskDelay(4000 / portTICK_PERIOD_MS);
			// 	continue;
			// }

			file.Close();

			ESP_LOGI(TAG, "... socket send success");
			close(client_socket);
			return;


			//EventBits_t staBits = xEventGroupWaitBits(wifi_event_group,WAIT_FOR_STOP_BIT,false,true,1);
			// if (staBits == 1){
			// 	close(socket);
			// 	vTaskDelete(NULL);
			// 	ESP_LOGI(TAG, "... server will be closed");
			// 	break;
			// }

		}
		ESP_LOGI(TAG, "... server will be closed in 5 seconds");
		vTaskDelay(5000 / portTICK_PERIOD_MS);

		break;
	}

	ESP_LOGI(TAG, "...tcp_client task closed\n");
}

int CWifi::response_to_client(int client_socket){
	// CWifiIO::WriteFlags flag;
	// int r; // Amount of bytes we read from wifiio
	// char buffer[64];
	//
	// do{
	// 	flag = m_Wio->GetWriteFlag();
	//
	// 	r = m_Wio->ReadFromWriteBuff(buffer, sizeof(buffer));
	// 	if(r && write(client_socket, buffer, r) < 0){
	// 		m_Wio->m_Error = 1;
	// 		return -1;
	// 	}
	// } while(flag != CWifiIO::WRITE_BUFF_CAN_BE_READ || r != 0);

	return 0;
}

void CWifi::start_dhcp_server(){
	tcpip_adapter_init();

	ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));

	tcpip_adapter_ip_info_t info;
	memset(&info, 0, sizeof(info));
	IP4_ADDR(&info.ip, 192, 168, 1, 1);
	IP4_ADDR(&info.gw, 192, 168, 1, 1);
	IP4_ADDR(&info.netmask, 255, 255, 255, 0);
	ESP_ERROR_CHECK(tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_AP, &info));
	// start the DHCP server
	ESP_ERROR_CHECK(tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP));
	printf("DHCP server started \n");
}



void printStationList()
{
	printf(" Connected stations:\n");
	printf("--------------------------------------------------\n");

	wifi_sta_list_t wifi_sta_list;
	tcpip_adapter_sta_list_t adapter_sta_list;

	memset(&wifi_sta_list, 0, sizeof(wifi_sta_list));
	memset(&adapter_sta_list, 0, sizeof(adapter_sta_list));

	ESP_ERROR_CHECK(esp_wifi_ap_get_sta_list(&wifi_sta_list));
	ESP_ERROR_CHECK(tcpip_adapter_get_sta_list(&wifi_sta_list, &adapter_sta_list));

	for(int i = 0; i < adapter_sta_list.num; i++) {

		tcpip_adapter_sta_info_t station = adapter_sta_list.sta[i];
         printf("%d - mac: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x - IP: %s\n", i + 1,
				station.mac[0], station.mac[1], station.mac[2],
				station.mac[3], station.mac[4], station.mac[5],
				ip4addr_ntoa(&(station.ip)));
	}

	printf("\n");
}


void print_sta_info(void *pvParam){
	printf("print_sta_info task started \n");
	while(1) {
		EventBits_t staBits = xEventGroupWaitBits(wifi_event_group, CLIENT_CONNECTED_BIT | CLIENT_CONNECTED_BIT, pdTRUE, pdFALSE, portMAX_DELAY);
		if((staBits & CLIENT_CONNECTED_BIT) != 0) printf("New station connected\n\n");
		else printf("A station disconnected\n\n");
		printStationList();
	}
}
